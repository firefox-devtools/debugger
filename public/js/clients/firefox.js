"use strict";

const { DebuggerClient } = require("ff-devtools-libs/shared/client/main");
const { DebuggerTransport } = require("ff-devtools-libs/transport/transport");
const { TargetFactory } = require("ff-devtools-libs/client/framework/target");
const defer = require("../util/defer");

let currentClient = null;
let currentThreadClient = null;
let currentTabTarget = null;

function getThreadClient() {
  return currentThreadClient;
}

function setThreadClient(client) {
  currentThreadClient = client;
}

function getTabTarget() {
  return currentTabTarget;
}

function setTabTarget(target) {
  currentTabTarget = target;
}

function lookupTabTarget(tab) {
  const options = { client: currentClient, form: tab, chrome: false };
  return TargetFactory.forRemoteTab(options);
}

function presentTabs(tabs) {
  return tabs.map(tab => {
    return {
      title: tab.title,
      url: tab.url,
      id: tab.actor,
      tab,
      browser: "firefox"
    };
  });
}

function connectClient() {
  const deferred = defer();
  let isConnected = false;

  const socket = new WebSocket("ws://localhost:9000");
  const transport = new DebuggerTransport(socket);
  currentClient = new DebuggerClient(transport);

  // TODO: the timeout logic should be moved to DebuggerClient.connect.
  setTimeout(() => {
    if (isConnected) {
      return;
    }

    deferred.resolve([]);
  }, 1000);

  currentClient.connect().then(() => {
    isConnected = true;
    return currentClient.listTabs().then(response => {
      deferred.resolve(presentTabs(response.tabs));
    });
  }).catch(err => {
    console.log(err);
    deferred.reject();
  });

  return deferred.promise;
}

function connectThread(tab, onNavigate) {
  return new Promise((resolve, reject) => {
    window.addEventListener("beforeunload", () => {
      getTabTarget().destroy();
    });

    lookupTabTarget(tab).then(target => {
      currentTabTarget = target;
      target.activeTab.attachThread({}, (res, threadClient) => {
        threadClient.resume();
        currentThreadClient = threadClient;
        resolve();
      });
    });
  });
}

function formatFrame(frame) {
  let title;
  if (frame.type == "call") {
    let c = frame.callee;
    title = c.name || c.userDisplayName || c.displayName || "(anonymous)";
  } else {
    title = "(" + frame.type + ")";
  }

  return {
    id: frame.actor,
    displayName: title,
    location: {
      sourceId: frame.where.source.actor,
      line: frame.where.line,
      column: frame.where.column
    }
  };
}

const CALL_STACK_PAGE_SIZE = 25;

function initPage(actions) {
  const tabTarget = getTabTarget();
  const client = getThreadClient();

  tabTarget.on("will-navigate", actions.willNavigate);
  tabTarget.on("navigate", actions.navigate);

  client.addListener("paused", (_, packet) => {
    // If paused by an explicit interrupt, which are generated by the
    // slow script dialog and internal events such as setting
    // breakpoints, ignore the event.
    if (packet.why.type === "interrupted" && !packet.why.onNext) {
      return;
    }

    client.getFrames(0, CALL_STACK_PAGE_SIZE, res => {
      actions.loadedFrames(res.frames.map(formatFrame));
    });

    const pause = Object.assign({}, packet, {
      frame: formatFrame(packet.frame)
    });
    actions.paused(pause);
  });
  client.addListener("resumed", (_, packet) => actions.resumed(packet));
  client.addListener("newSource", (_, packet) => {
    const source = {
      id: packet.source.actor,
      url: packet.source.url,

      // Internal fields for Firefox
      actor: packet.source.actor
    };

    actions.newSource(source);
  });

  actions.loadSources();
}

module.exports = {
  connectClient,
  connectThread,
  getThreadClient,
  setThreadClient,
  getTabTarget,
  setTabTarget,
  initPage
};
