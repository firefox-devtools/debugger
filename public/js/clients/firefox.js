"use strict";

const { DebuggerClient } = require("ff-devtools-libs/shared/client/main");
const { DebuggerTransport } = require("ff-devtools-libs/transport/transport");
const { TargetFactory } = require("ff-devtools-libs/client/framework/target");
const { Source, Location, Frame } = require("../types");

let currentClient = null;
let currentThreadClient = null;
let currentTabTarget = null;

// API implementation

let APIClient = {
  resume() {
    return new Promise(resolve => {
      currentThreadClient.resume(resolve);
    });
  },

  stepIn() {
    return new Promise(resolve => {
      currentThreadClient.stepIn(resolve);
    });
  },

  stepOver() {
    return new Promise(resolve => {
      currentThreadClient.stepOver(resolve);
    });
  },

  stepOut() {
    return new Promise(resolve => {
      currentThreadClient.stepOut(resolve);
    });
  },

  getSources() {
    return currentThreadClient.getSources();
  },

  sourceContents(sourceId) {
    const sourceClient = currentThreadClient.source({ actor: sourceId });
    return sourceClient.source();
  },

  setBreakpoint(location, condition) {
    const sourceClient = currentThreadClient.source({
      actor: location.sourceId
    });
    return sourceClient.setBreakpoint({
      line: location.line,
      column: location.column,
      condition: condition
    });
  }
};

function getAPIClient() {
  return APIClient;
}

// Connection handling

function getThreadClient() {
  return currentThreadClient;
}

function setThreadClient(client) {
  currentThreadClient = client;
}

function getTabTarget() {
  return currentTabTarget;
}

function setTabTarget(target) {
  currentTabTarget = target;
}

function lookupTabTarget(tab) {
  const options = { client: currentClient, form: tab, chrome: false };
  return TargetFactory.forRemoteTab(options);
}

function createTabs(tabs) {
  return tabs.map(tab => {
    return {
      title: tab.title,
      url: tab.url,
      id: tab.actor,
      tab,
      browser: "firefox"
    };
  });
}

function connectClient(onConnect) {
  const socket = new WebSocket("ws://localhost:9000");
  const transport = new DebuggerTransport(socket);
  currentClient = new DebuggerClient(transport);

  currentClient.connect().then(() => {
    return currentClient.listTabs().then(response => {
      onConnect(createTabs(response.tabs));
    });
  }).catch(err => console.log(err));
}

function connectTab(tab) {
  return new Promise((resolve, reject) => {
    window.addEventListener("beforeunload", () => {
      getTabTarget().destroy();
    });

    lookupTabTarget(tab).then(target => {
      currentTabTarget = target;
      target.activeTab.attachThread({}, (res, threadClient) => {
        threadClient.resume();
        currentThreadClient = threadClient;
        resolve();
      });
    });
  });
}

function createFrame(frame) {
  let title;
  if (frame.type == "call") {
    let c = frame.callee;
    title = c.name || c.userDisplayName || c.displayName || "(anonymous)";
  } else {
    title = "(" + frame.type + ")";
  }

  return Frame({
    id: frame.actor,
    displayName: title,
    location: Location({
      sourceId: frame.where.source.actor,
      line: frame.where.line,
      column: frame.where.column
    })
  });
}

const CALL_STACK_PAGE_SIZE = 25;

function initPage(actions) {
  const tabTarget = getTabTarget();
  const client = getThreadClient();

  tabTarget.on("will-navigate", actions.willNavigate);
  tabTarget.on("navigate", actions.navigate);

  client.addListener("paused", (_, packet) => {
    // If paused by an explicit interrupt, which are generated by the
    // slow script dialog and internal events such as setting
    // breakpoints, ignore the event.
    if (packet.why.type === "interrupted" && !packet.why.onNext) {
      return;
    }

    client.getFrames(0, CALL_STACK_PAGE_SIZE, res => {
      actions.loadedFrames(res.frames.map(createFrame));
    });

    const pause = Object.assign({}, packet, {
      frame: createFrame(packet.frame)
    });
    actions.paused(pause);
  });

  client.addListener("resumed", (_, packet) => actions.resumed(packet));
  client.addListener("newSource", (_, packet) => {
    actions.newSource(Source({
      id: packet.source.actor,
      url: packet.source.url,

      // Internal for Firefox for now
      actor: packet.source.actor
    }));
  });

  actions.loadSources();
}

module.exports = {
  connectClient,
  connectTab,
  getAPIClient,
  getThreadClient,
  setThreadClient,
  getTabTarget,
  setTabTarget,
  initPage
};
